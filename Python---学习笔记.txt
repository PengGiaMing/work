1.tuple是一个不可变的序列, 不能对它的元素赋值
（数值型number、字符串string均为不可变的对象，而字典可以修改成功）

2.对字典的赋值成功，但是后来发生的元组赋值失败造成的
（是先对字典进行了iadd操作并且成功，而之后的tuple赋值失败报错）

3.对原有的tuple中的字典直接赋值不会成功
（变量赋值采用对象引用的方式，传递的是一个对象的内存地址---像一个指针）

4.检索名称存储在字符串中的字段，请使用以下getattr() 函数：
p = 'xxxxxxxxx'
getattr(p,'x')

5.将字典转换为命名元组:
d = {'x': 11, 'y': 22}
Point(**d)

6.控制流语句：
    if:可以有零个或多个elif零件，else零件是可选的
    for:迭代任何序列的项目（列表或string），按照它们出现在序列中的顺序
    range():迭代一系列数字
	(它是一个对象，当迭代它时，它返回所需序列的连续项，但它不是列表)

7.循环语句可能有一个else子句， 
  当循环通过列表耗尽或条件变为false时终止，输出else子句中的语句，
  但是当循环被break语句终止时不执行else子句
  
  continue---继续循环的下一次迭代

8.pass语句---当语法需要语句但程序不需要操作时，可以使用它

9.关键字def引入了一个函数定义。它必须后跟函数名称和带括号的形式参数列表。构成函数体的语句从下一行开始，并且必须缩进

  return语句返回一个函数的值。 return没有表达式参数返回None。从函数的末尾掉落也会返回None。

10. 默认值仅评估一次。当默认值是可变对象（列表、字典等大多数实例）时，这会产生差异。

11.在函数调用中，关键字参数必须遵循位置参数。传递的所有关键字参数必须与函数接受的参数之一匹配，并且它们的顺序并不重要。

12.当**name存在表单的最终形式参数时，它接收包含除了与形式参数相对应的所有关键字参数的字典

   *name接收包含超出形式参数列表的位置参数的元组。（*name必须在之前发生**name）

   打印关键字参数的顺序保证与函数调用中提供它们的顺序相匹配。

13.注释__annotations__作为字典存储在函数的属性中，对函数的任何其他部分没有影响。
  
   参数注释由参数名称后面的冒号定义，后跟一个表达式，用于评估注释的值。

   返回注释由->参数列表和表示def语句结尾的冒号之间的文字，后跟表达式定义。

14.operator模块导出一组与Python的内部运算符相对应的高效函数

   比较运算符:
	operator.lt（a，b） le（a，b）eq（a，b）ne（a，b）ge（a，b）gt（a，b)
	相当于、等同于、相当于、等同于、相当于、相当于
   逻辑运算：
	operator.not_（obj） operator.truth（obj） operator.is_（a，b）---检验对象是否相等

	operator.abs（obj）---绝对值  operator.add（a，b ） operator.and_（a,b）

	operator.floordiv（a，b ）---相当于a // b  operator.index（a）---转换为整数

	operator.inv（obj）---对obj对象按位取反的值  operator.lshift（a，b）---左移b

	operator.mod（a，b）---相当于a%b   operator.mul（a，b）返回 a*b

	operator.or_（a，b)---按位或a和b   operator.rshift（a，b）---右移b

	operator.neg(obj)--- obj对象的相反数(-obj)   operator.or_(a, b)---返回 a | b
	
	operator.pow(a, b)---返回 a** b（乘方） .............

15.PEP 3101 - 高级字符串格式

   'format'，它接受任意数量的位置和关键字参数

   '{}'标记不是从格式字符串直接传输到输出，而是用于定义“替换字段”，它们向格式引擎描述应该在输出字符串中放置什么来代替标记

   格式说明符---可用于调整该字段的格式
	
   格式说明符本身可以包含替换字段(“{0：{1}}”。格式（a，b）) 
      注：通常会被转义的结尾处的加倍'}'不会被转义原因是因为转义的'{{'和'}}'语法仅在格式字段外使用时才应用

   标准格式说明符:

   对齐标志---  '<' - 强制字段在可用范围内左对齐  '>' - 强制字段在字段内右对齐  '^' - 强制字段在可用范围内居中  

   整数表示类型----  'b' - 二进制  'c'将整数转换为相应的打印前的Unicode字符  'd' - 十进制整数 'o' - 八进制格式 
		    'x'、'X' - 十六进制格式 

   浮点表示类型---  'e' - 指数表示法 'E'(转换为大写)  'f' - 浮点 'F'（转换为大写） 'g' - 一般格式，这会将数字打印为浮点
		    ''（无） - 类似于'g'，但它打印至少一个小数点后的数字

   'format'是主要的API方法。它需要一个格式模板，以及一组任意的位置和关键字参数。'format'只是一个调用'vformat'的包装器。

   'vformat'是执行格式化实际工作的函数。

    Formatter定义了以下可覆盖的方法：

    -  get_value（key，args，kwargs）
    -  check_unused_args（used_args，args，kwargs）
    -  format_field（value，format_spec）

   'get_value'用于检索给定的字段值。'key'参数可以是整数或字符串。
   如果它是一个整数，它表示'args'中位置参数的索引; 如果它是一个字符串，那么它代表'kwargs'中的命名参数。

   'args'参数设置为'vformat'的位置参数列表，'kwargs'参数设置为位置参数字典。

   对于复合字段名称，仅为字段名称的第一个组件调用这些函数; 后续组件通过常规属性和索引操作来处理。

   因此，例如，字段表达式“0.name”将导致使用'key'参数为0调用'get_value'。
   在'get_value'返回后，通过调用内置函数来查找'name'属性getattr'功能。

   如果索引或关键字引用了不存在的项， 则应引发IndexError / KeyError。

   如果需要，'check_unused_args'用于实现对未使用参数的检查。
 
  'format_field'只是调用内置的全局'format'。提供该方法以便子类可以覆盖它。

   格式化程序代码本身生成的异常属于“ValueError”类型 - 格式字符串的实际“值”中存在错误。
     （这些内部生成的ValueError 异常相关联的文本将指示格式字符串中异常的位置，以及异常的性质）

   用户代码生成的异常，跟踪记录和虚拟框架将添加到回溯堆栈，以帮助确定发生异常的字符串中的位置   